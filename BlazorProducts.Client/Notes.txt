These notes are taken following the tutorial found in:
https://code-maze.com/blazor-components/


Blazor Components:
========================================

* Are the key pieces in this technology
* They are composed by HTML elements and code
* Of course HTML elements need to be configured to present some state to the UI
		This visual/content configuration has to be dynamic
		Dynamic behaviour can be achieved by indicating within the elements some variables that can be configured and injected from the container that will use the component.

		Dynamic Content:
				- Just declare that the content depends on a @parameter. And then in the @code section specify a c# property that will yield the required content. Those c# properties has to be decorated with the [Parameter] decorator
				- When declared inside a component, it is just necessary to set the value of the parameter as if it was just another html attribute of the component.
				- Even when it is good for simple pieces of content, when trying to pass more complex content through a parameter it could be hard to read/mantain. For this purpose we can use the RenderFragment parameter that can represent plain text, html, or whole other components

				RenderFragment: By default, it takes the ChildContent as the name of the parameter. If you specify another name you have to indicate the custom name also in the container. If not, you won't need to include it. 
				
				Cascading Parameters:				
						Sometimes, it is desired to have some parameters to be set automatically without declaring them explicitly in each component inside the container.
						(Useful for example when a given parameter is required to be shared among various components inside a container)
						To achieve this, the attribute is declared as a [CascadigParameter] both in the component and in the container.
						The container declares the attribute as a field with a given value:
						private readonly string _color = "#0505b5";
						While the component declares it as a normal property with the decorator [CascadigParameter] the name of the property is irrelevant, since Blazor just check for the type od the property and there is only one property to pass in cascade.
						So if we need to pass multiple values, we create a type with all those values.
						If desired, the cascading parameter can also be referenced by name adding some sintaxis sugar:
						<CascadingValue Name="HeadingColor" Value="@_color">  in the container and then [CascadingParameter(Name = "HeadingColor")] in the component


		Elements style:
				Can be bound to a Dictionary<string, object> that will contain the key/values for all the properties that the elements could have if the (CaptureUnmatchedValues=true) modificator for the [Parameter] decorator is set:
				[Parameter(CaptureUnmatchedValues = true)]
				public Dictionary<string, object> AdditionalAttributes { get; set; }

		Then, the container (this is: the component caller), could specify those attributes from the component declaration itself:
		<Home Title="Welcome to the BlazorProducts.Client application." 
      src="/assets/products.png" alt="products image for the Home component"></Home>
			And those attributes would be injected wherever they apply in a normal HTML

		The container could also determine a property of type Dictionary<string, object> that could have the additional attributes listed inside so the code could be more readable:
		<Home @attributes="AdditionalAttributes"></Home>
		
		@code{
    public Dictionary<string, object> AdditionalAttributes { get; set; } = new Dictionary<string, object>
    {
        { "src", "/assets/products.png" },
        { "alt", "products image for the Home component" }
    };

		In this case, the container creates the dictionary that the comnponent expects as a parameter. And the component then distributes the key/values within its HTML elements


	Partial Classes
	========================================
	Creating a file in the same folder as a .razor component with the same name and the extension .razor.cs will create an association between the component and its code behind, but the "partial" keyword must be added manually
	

	Blazor Lifecycle
	=======================================
	Most Useful:
	* StateHasChanged: For example to order the hiding of a modal window after the user closes it.


	Routing & Navigation
	=======================================
	It is enabled by injecting the service NavigationManager in the code of the component:
	 public NavigationManager NavigationManager { get; set; }

        public void NavigateToHome()
        {
            NavigationManager.NavigateTo("/");
        }
    }

		We have other utilities in the navigator like getting the current url: NavigationManager.Uri





	CSS Stylesheets:
	=======================================
	Can be created anywhere. Even inside a folder of pages to better organizations using CSS Isolation. Once created, they must referenced from the INDEX.HTML <==== the HTML!!! And the cache of the site must be refreshed in order to get the styling visually updating when rendering the application.




	HTTP CLIENT
	=======================================
	It must be registered in the Main method of the Program class (this is done by default).
	A repository pattern for http data is recommended to be implemented using the httpclient service
	This repository is registered also in the main method of the program class.
	The repository is then [Inject]ed in each component that needs it.
	Within the component code, we call the data in the equivalent event to the old OnLoad of the WebForms: OnInitializedAsync. All of this is configured in a razor page that will contain this razor component which will have the logic and design to present the data. This component will require a [Parameter] field containing the data the container page sends to it. We can configure this 



	PAGINATION
	============================================
	A class for configuring parameters for querying a type of object is recommended to have the mazpagesize, the current page number, the page size. This should be crepart of the shared entities. A metadata class is also recommended to determine info about the current page we are working with. For example CurrentPage, TotalPages, PageSize, TotalCount, HasPrevious, HasNext. THis is used for the client side pagination. Then the back should have a pagedlist of entities with metadata, the paged list representing each page (with metadata and data) and fo course an operation to return a paged list after querynf the repository with the parameters passed. There is an important fact in the controller returning the page and it is adding a header to the response, that will contain the metadata of the page. That header is called "X-Pagination" (this could be simply included in the response as another field, but I guess webassebmly could make some auto operations based on this convention. This header must be added to the cors policy).

	Create query strings easy with a dictionary<string, string>: QueryHelpers.AddQueryString from Microsoft.AspNetCore.WebUtilities.

	The pagination in the client requires a component that will serve as the index of links to show. This component is basically a list of links displayed horizontally witha next and previous.

	This list of links must be presented using some parameters. Both the links list and parameters should make part of the codebehind of the component. It also have to contain and eventcallback and a method to create the list as well and event to react whwnever a link is clicked by the user.

	This component will be embedded in a container where some initialization parameters are specified. Through the eventcallback, the pagination component tells the container what next page was asked and then then the container calls the service to bring that content. That is done setting the productparameters and with the response from the service, the fresh data is shown to the user.



	SEARCHING
	===========================================
